java.lang.Error: 
============================================================
Javac compiles reincarnation.decompiler.flow.SwitchTest$70
============================================================
null
AssertionError: null
    at reincarnation.CodeVerifier$JavaVerifier.assertObject(CodeVerifier.java:462)
    at reincarnation.CodeVerifier$JavaVerifier.verify(CodeVerifier.java:438)
    at reincarnation.CodeVerifier.verify(CodeVerifier.java:185)
    at reincarnation.decompiler.flow.SwitchTest.conditionByStringWithMethodCondition(SwitchTest.java:1727)
    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)

============================================================
Original Code
============================================================
@Debuggable
    void conditionByStringWithMethodCondition() {
        verify(new TestCode.TextParam() {

            @Override
            public String run(@Param(strings = {"aa", "ab", "ac", "ba", "bb"}) String param) {
                switch (param.substring(0, 1)) {
                case "a":
                    return "A";

                default:
                    return param;
                }
            }
        });
    }
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.Param;
05    import reincarnation.TestCode.TextParam;
06    import reincarnation.decompiler.flow.SwitchTest;
07    
08    class SwitchTest extends CodeVerifier {
09    
10        class SwitchTest$70 implements TextParam {
11    
12            SwitchTest$70(final SwitchTest this$0) {
13            }
14    
15            public String run(@Param(strings = {"aa", "ab", "ac", "ba", "bb"}) String param) {
16                switch (param) {
17                    case "a":
18                        return "A";
19                }
20                return param;
21            }
22        }
23    }
============================================================
Decompiling Log
============================================================
//------------------------- SwitchTest#conditionByStringWithMethodCondition (SwitchTest.java:1726) -------------------------//
Method conditionByStringWithMethodCondition() (SwitchTest.java:1727)
0	in[]	out[]	dom[]	doms[]	side[ ,1]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]
1	in[]	out[]	dom[]	doms[]	side[0, ]	dest[]	code: 

Delete tail empty return (show full nodes)
0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]

0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]


0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]

//------------------------- SwitchTest#conditionByStringWithMethodCondition (SwitchTest.java:1730) -------------------------//
Method conditionByStringWithMethodCondition() (SwitchTest.java:1736)
0	in[]	out[2,1]	dom[]	doms[]	side[ ,1]	dest[1]	code: local2 = param.substring(0,1) [Assign#String] local3 = -1 [Assign] switch (param) [Switch]
1	in[0]	out[2]		dom[0]	doms[]	side[0,2]	dest[2]	code: if (local2.equals("a") 0) then 2 else SAME [Condition then 2 else SAME] local3 = 0 [Assign]
2	in[0,1]	out[4,3]	dom[0]	doms[]	side[1,3]	dest[3]	code: switch (local3) [Switch]
3	in[2]	out[]		dom[2]	doms[]	side[2,4]	dest[T]	code: return "A" [Return#String - String]
4	in[2]	out[]		dom[2]	doms[]	side[3,5]	dest[T]	code: return param [Return#String - LocalVariable#String]
5	in[]	out[]		dom[]	doms[]	side[4, ]	dest[]	code: 

0	in[]		out[2,1]	dom[]	doms[1,2]	side[ ,1]	dest[1]	code: local2 = param.substring(0,1) [Assign#String] local3 = -1 [Assign] switch (param) [Switch]
1	in[0]		out[2,A]	dom[0]	doms[A]		side[0,A]	dest[2]	code: if (local2.equals("a") 0) then 2 else SAME [Condition then 2 else SAME]
A	in[1]		out[2]		dom[1]	doms[]		side[1,2]	dest[]	code: local3 = 0 [Assign]
2	in[0,1,A]	out[4,3]	dom[]	doms[3,4]	side[A,3]	dest[3]	code: switch (local3) [Switch]
3	in[2]		out[]		dom[2]	doms[]		side[2,4]	dest[T]	code: return "A" [Return#String - String]
4	in[2]		out[]		dom[2]	doms[]		side[3, ]	dest[T]	code: return param [Return#String - LocalVariable#String]


============================================================
Bytecode Diff -  reincarnation.decompiler.flow.SwitchTest$70
============================================================
ECJ																					Javac
visitMethod(ACC_PUBLIC, "run", "(Lj.l.String;)Lj.l.String;", null, null);			visitMethod(ACC_PUBLIC, "run", "(Lj.l.String;)Lj.l.String;", null, null);
~Parameter("param", 0);~															
AnnotableParameterCount(1, true);													AnnotableParameterCount(1, true);
Label(L0);																			Label(L0);
VarInsn(ALOAD, 1);																	VarInsn(ALOAD, 1);
Insn(ICONST_0);																		Insn(ICONST_0);
Insn(ICONST_1);																		Insn(ICONST_1);
MethodInsn(INVOKEVIRTUAL, "j.l.String", "substring", "(II)Lj.l.String;", false);	MethodInsn(INVOKEVIRTUAL, "j.l.String", "substring", "(II)Lj.l.String;", false);
~Insn(DUP);~																		
VarInsn(ASTORE, 2);																	VarInsn(ASTORE, 2);
																					+Insn(ICONST_M1);+
																					+VarInsn(ISTORE, 3);+
																					+VarInsn(ALOAD, 2);+
MethodInsn(INVOKEVIRTUAL, "j.l.String", "hashCode", "()I", false);					MethodInsn(INVOKEVIRTUAL, "j.l.String", "hashCode", "()I", false);
LookupSwitchInsn(L2, new int[] { 97 }, new Label[] { L1 });							LookupSwitchInsn(L2, new int[] { 97 }, new Label[] { L1 });
Label(L1);																			Label(L1);
Frame(F_APPEND,~1~, new Object[] {"j.l.String"}, 0, null);							Frame(F_APPEND,+2+, new Object[] {"j.l.String"+, INTEGER+}, 0, null);
VarInsn(ALOAD, 2);																	VarInsn(ALOAD, 2);
LdcInsn("a");																		LdcInsn("a");
MethodInsn(INVOKEVIRTUAL, "j.l.String", "equals", "(Lj.l.Object;)Z", false);		MethodInsn(INVOKEVIRTUAL, "j.l.String", "equals", "(Lj.l.Object;)Z", false);
JumpInsn(~IFNE~, ~L3~);																JumpInsn(+IFEQ+, +L2+);
~JumpInsn~(~GOTO, L2~);																+Insn+(+ICONST_0+);
																					+VarInsn(ISTORE, 3);+
																					+Label(L2);+
																					+Frame(F_SAME, 0, null, 0, null);+
																					+VarInsn(ILOAD, 3);+
																					+LookupSwitchInsn(L4, new int[] { 0 }, new Label[] { L3 });+
Label(L3);																			Label(L3);
Frame(F_SAME, 0, null, 0, null);													Frame(F_SAME, 0, null, 0, null);
LdcInsn("A");																		LdcInsn("A");
Insn(ARETURN);																		Insn(ARETURN);
Label(~L2~);																		Label(+L4+);
Frame(F_SAME, 0, null, 0, null);													Frame(F_SAME, 0, null, 0, null);
VarInsn(ALOAD, 1);																	VarInsn(ALOAD, 1);
Insn(ARETURN);																		Insn(ARETURN);
Label(~L4~);																		Label(+L5+);
LocalVariable("this", "LSwitchTest$70;", null, L0, ~L4~, 0);						LocalVariable("this", "LSwitchTest$70;", null, L0, +L5+, 0);
LocalVariable("param", "Lj.l.String;", null, L0, ~L4~, 1);							LocalVariable("param", "Lj.l.String;", null, L0, +L5+, 1);
============================================================



java.lang.Error: 
============================================================
ECJ compiles reincarnation.decompiler.flow.SwitchExpressionTest$30
============================================================
/reincarnation/decompiler/flow/SwitchExpressionTest.java:20: エラー: case、defaultまたは'}'がありません
"a"                    case  -> "AA";
^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:20: エラー: 式の開始が不正です
"a"                    case  -> "AA";
                             ^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:21: エラー: case、defaultまたは'}'がありません
"b"                    case  -> "AB";
^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:21: エラー: 式の開始が不正です
"b"                    case  -> "AB";
                             ^

Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
NullPointerException: Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
    at reincarnation.CodeVerifier$JavaVerifier.<init>(CodeVerifier.java:379)
    at reincarnation.CodeVerifier.verify(CodeVerifier.java:182)
    at reincarnation.decompiler.flow.SwitchExpressionTest.conditionByStringNest(SwitchExpressionTest.java:545)
    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
    at java.base/java.lang.reflect.Method.invoke(Method.java:580)

============================================================
Original Code
============================================================
void conditionByStringNest() {
        verify(new TestCode.TextParam() {

            @Override
            public String run(@Param(strings = {"aa", "ab", "ac", "ba", "bb"}) String param) {
                return switch (param.substring(0, 1)) {
                case "a" -> switch (param.substring(1, 2)) {
                case "a" -> "AA";
                case "b" -> "AB";
                default -> "AC";
                };

                default -> param;
                };
            }
        });
    }
}
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.Param;
05    import reincarnation.TestCode.TextParam;
06    import reincarnation.decompiler.flow.SwitchExpressionTest;
07    
08    class SwitchExpressionTest extends CodeVerifier {
09    
10        class SwitchExpressionTest$30 implements TextParam {
11            final SwitchExpressionTest this$0;
12    
13            SwitchExpressionTest$30(final SwitchExpressionTest this$0) {
14                this.this$0 = this$0;
15            }
16    
17            public String run(@Param(strings = {"aa", "ab", "ac", "ba", "bb"}) String param) {
18                return switch (param.substring(0, 1)) {
19                    case "a" -> switch (param.substring(1, 2)) {
20    "a"                    case  -> "AA";
21    "b"                    case  -> "AB";
22                        default -> {
23                            yield "AC";
24                        }
25                    };
26                    default -> param;
27                };
28            }
29        }
30    }
============================================================
Decompiling Log
============================================================
//----------------------- SwitchExpressionTest#conditionByStringNest (SwitchExpressionTest.java:544) -----------------------//
Method conditionByStringNest() (SwitchExpressionTest.java:545)
0	in[]	out[]	dom[]	doms[]	side[ ,1]	dest[T]	code: this.this$0 = this$0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall] return null [Return - null]
1	in[]	out[]	dom[]	doms[]	side[0, ]	dest[]	code: 

Delete tail empty return (show full nodes)
0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = this$0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall] return null [Return - null]

0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = this$0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall]


0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: this.this$0 = this$0 [Assign#SwitchExpressionTest] java.lang.Object() [ConstructorCall]

//----------------------- SwitchExpressionTest#conditionByStringNest (SwitchExpressionTest.java:548) -----------------------//
Method conditionByStringNest() (SwitchExpressionTest.java:549)
3	in[1]		out[7,5,6]	dom[1]	doms[]	side[4,5]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch]
5	in[3]		out[8,9]	dom[3]	doms[]	side[3,9]	dest[9]		code: if (local3.equals("a") 0) then 8 else 9 [Condition then 8 else 9]
9	in[5]		out[7]		dom[5]	doms[]	side[5,6]	dest[7]		code: 
6	in[3]		out[10,11]	dom[3]	doms[]	side[9,11]	dest[11]	code: if (local3.equals("b") 0) then 10 else 11 [Condition then 10 else 11]
11	in[6]		out[7]		dom[6]	doms[]	side[6,8]	dest[7]		code: 
8	in[5]		out[12]		dom[5]	doms[]	side[11,10]	dest[12]	code: "AA" [String]
10	in[6]		out[12]		dom[6]	doms[]	side[8,7]	dest[12]	code: "AB" [String]
7	in[3,9,11]	out[13]		dom[3]	doms[]	side[10,13]	dest[13]	code: "AC" [String]
13	in[7]		out[12]		dom[7]	doms[]	side[7,2]	dest[12]	code: 

Analyze switch [Range 3 - 13] (show full nodes)
3	in[1]		out[7,5,6]	dom[1]	doms[5,6,7]	side[4,5]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch]
5	in[3]		out[8,9]	dom[3]	doms[9,8]	side[3,9]	dest[9]		code: if (local3.equals("a") 0) then 8 else 9 [Condition then 8 else 9]
9	in[5]		out[7]		dom[5]	doms[]		side[5,6]	dest[7]		code: 
6	in[3]		out[10,11]	dom[3]	doms[11,10]	side[9,11]	dest[11]	code: if (local3.equals("b") 0) then 10 else 11 [Condition then 10 else 11]
11	in[6]		out[7]		dom[6]	doms[]		side[6,8]	dest[7]		code: 
8	in[5]		out[12]		dom[5]	doms[]		side[11,10]	dest[12]	code: "AA" [String]
10	in[6]		out[12]		dom[6]	doms[]		side[8,7]	dest[12]	code: "AB" [String]
7	in[3,9,11]	out[13]		dom[3]	doms[13]	side[10,13]	dest[13]	code: "AC" [String]
13	in[7]		out[12]		dom[7]	doms[]		side[7,2]	dest[12]	code: 

3	in[]	out[7,8,10]	dom[]	doms[5,6,7]	side[4,8]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
5	in[]	out[]		dom[]	doms[9,8]	side[3,6]	dest[7]		code: 
9	in[]	out[]		dom[]	doms[]		side[5,6]	dest[7]		code: 
6	in[]	out[]		dom[]	doms[11,10]	side[3,8]	dest[7]		code: 
11	in[]	out[]		dom[]	doms[]		side[6,8]	dest[7]		code: 
8	in[3]	out[]		dom[3]	doms[]		side[3,10]	dest[12]	code: yield "AA" [Yield#String - "AA"]
10	in[3]	out[]		dom[3]	doms[]		side[8,7]	dest[12]	code: yield "AB" [Yield#String - "AB"]
7	in[3]	out[13]		dom[3]	doms[13]	side[10,13]	dest[13]	code: yield "AC" [Yield#String - "AC"]
13	in[7]	out[]		dom[7]	doms[]		side[7,2]	dest[12]	code: 


3	in[]	out[7,8,10]	dom[]	doms[5,6,7]	side[4,8]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
5	in[]	out[]		dom[]	doms[9,8]	side[3,6]	dest[7]		code: 
9	in[]	out[]		dom[]	doms[]		side[5,6]	dest[7]		code: 
6	in[]	out[]		dom[]	doms[11,10]	side[3,8]	dest[7]		code: 
11	in[]	out[]		dom[]	doms[]		side[6,8]	dest[7]		code: 
8	in[3]	out[]		dom[3]	doms[]		side[3,10]	dest[12]	code: yield "AA" [Yield#String - "AA"]
10	in[3]	out[]		dom[3]	doms[]		side[8,7]	dest[12]	code: yield "AB" [Yield#String - "AB"]
7	in[3]	out[13]		dom[3]	doms[13]	side[10,13]	dest[13]	code: yield "AC" [Yield#String - "AC"]
13	in[7]	out[]		dom[7]	doms[]		side[7,2]	dest[12]	code: 

Transform switch expression [Range 3 - 13] (show full nodes)
0	in[]			out[2,1]	dom[]	doms[]	side[ ,1]	dest[1]		code: switch (param.substring(0,1)) [Switch]
1	in[0]			out[3,4]	dom[0]	doms[]	side[0,4]	dest[4]		code: if (local2.equals("a") 0) then 3 else 4 [Condition then 3 else 4]
4	in[1]			out[2]		dom[1]	doms[]	side[1,3]	dest[2]		code: 
3	in[1]			out[7,5,6]	dom[1]	doms[]	side[4,5]	dest[5]		code: switch (param.substring(1,2)) [Switch]
5	in[3]			out[8,9]	dom[3]	doms[]	side[3,9]	dest[9]		code: if (local3.equals("a") 0) then 8 else 9 [Condition then 8 else 9]
9	in[5]			out[7]		dom[5]	doms[]	side[5,6]	dest[7]		code: 
6	in[3]			out[10,11]	dom[3]	doms[]	side[9,11]	dest[11]	code: if (local3.equals("b") 0) then 10 else 11 [Condition then 10 else 11]
11	in[6]			out[7]		dom[6]	doms[]	side[6,8]	dest[7]		code: 
8	in[5]			out[12]		dom[5]	doms[]	side[11,10]	dest[12]	code: "AA" [String]
10	in[6]			out[12]		dom[6]	doms[]	side[8,7]	dest[12]	code: "AB" [String]
7	in[3,9,11]		out[13]		dom[3]	doms[]	side[10,13]	dest[13]	code: "AC" [String]
13	in[7]			out[12]		dom[7]	doms[]	side[7,2]	dest[12]	code: 
2	in[0,4]			out[12]		dom[0]	doms[]	side[13,12]	dest[12]	code: param [LocalVariable#String]
12	in[8,10,13,2]	out[]		dom[]	doms[]	side[2, ]	dest[]		code: 

0	in[]		out[2,1]	dom[]	doms[]		side[ ,1]	dest[1]		code: switch (param.substring(0,1)) [Switch]
1	in[0]		out[4,12,3]	dom[0]	doms[3]		side[0,4]	dest[4]		code: if (local2.equals("a") 0) then 3 else 4 [Condition then 3 else 4]
4	in[1]		out[2]		dom[1]	doms[]		side[1,3]	dest[2]		code: 
3	in[1]		out[12]		dom[1]	doms[5,6,7]	side[4,2]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
2	in[0,4]		out[12]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]
12	in[2,1,3]	out[]		dom[]	doms[]		side[2, ]	dest[]		code: 


Method conditionByStringNest() (SwitchExpressionTest.java:549)
0	in[]	out[2,1]	dom[]	doms[]		side[ ,1]	dest[1]		code: switch-expression (param.substring(0,1)) [Switch]
1	in[0]	out[4,12,3]	dom[0]	doms[3]		side[0,4]	dest[4]		code: if (local2.equals("a") 0) then 3 else 4 [Condition then 3 else 4]
4	in[1]	out[2]		dom[1]	doms[]		side[1,3]	dest[2]		code: 
3	in[1]	out[12]		dom[1]	doms[5,6,7]	side[4,2]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
2	in[0,4]	out[12]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]

Analyze switch [Range 0 - 2] (show full nodes)
0	in[]	out[2,1]	dom[]	doms[1,2]	side[ ,1]	dest[1]		code: switch-expression (param.substring(0,1)) [Switch]
1	in[0]	out[4,12,3]	dom[0]	doms[3,4]	side[0,4]	dest[4]		code: if (local2.equals("a") 0) then 3 else 4 [Condition then 3 else 4]
4	in[1]	out[2]		dom[1]	doms[]		side[1,3]	dest[2]		code: 
3	in[1]	out[12]		dom[1]	doms[5,6,7]	side[4,2]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
2	in[0,4]	out[12]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]

0	in[]	out[2,3]	dom[]	doms[1,2]	side[ ,3]	dest[1]		code: switch-expression (param.substring(0,1)) [Switch#String]
1	in[]	out[]		dom[]	doms[3,4]	side[0,3]	dest[2]		code: 
4	in[]	out[]		dom[]	doms[]		side[1,3]	dest[2]		code: 
3	in[0]	out[]		dom[0]	doms[5,6,7]	side[0,2]	dest[5]		code: yield switch-expression (param.substring(1,2)) [Yield#String - switch(String param.substring(1, 2)){ case:[#7, 8, 10, #7] follow:12}]
2	in[0]	out[]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]


0	in[]	out[2,3]	dom[]	doms[1,2]	side[ ,3]	dest[1]		code: switch-expression (param.substring(0,1)) [Switch#String]
1	in[]	out[]		dom[]	doms[3,4]	side[0,3]	dest[2]		code: 
4	in[]	out[]		dom[]	doms[]		side[1,3]	dest[2]		code: 
3	in[0]	out[]		dom[0]	doms[5,6,7]	side[0,2]	dest[5]		code: yield switch-expression (param.substring(1,2)) [Yield#String - switch(String param.substring(1, 2)){ case:[#7, 8, 10, #7] follow:12}]
2	in[0]	out[]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]

Transform switch expression [Range 0 - 2] (show full nodes)
0	in[]		out[2,1]	dom[]	doms[]		side[ ,1]	dest[1]		code: switch (param.substring(0,1)) [Switch]
1	in[0]		out[4,12,3]	dom[0]	doms[3]		side[0,4]	dest[4]		code: if (local2.equals("a") 0) then 3 else 4 [Condition then 3 else 4]
4	in[1]		out[2]		dom[1]	doms[]		side[1,3]	dest[2]		code: 
3	in[1]		out[12]		dom[1]	doms[5,6,7]	side[4,2]	dest[5]		code: switch-expression (param.substring(1,2)) [Switch#String]
2	in[0,4]		out[12]		dom[0]	doms[]		side[3,12]	dest[12]	code: yield param [Yield#String - param]
12	in[2,1,3]	out[]		dom[]	doms[]		side[2, ]	dest[]		code: 

0	in[]	out[12]	dom[]	doms[1,2]	side[ ,12]	dest[1]	code: switch-expression (param.substring(0,1)) [Switch#String]
12	in[0]	out[]	dom[0]	doms[]		side[0, ]	dest[]	code: 


Method conditionByStringNest() (SwitchExpressionTest.java:549)
0	in[]	out[12]	dom[]	doms[1,2]	side[ ,12]	dest[1]	code: 
12	in[0]	out[]	dom[0]	doms[]		side[0,14]	dest[T]	code: return switch-expression (param.substring(0,1)) [Return#String - Switch#String]
14	in[]	out[]	dom[]	doms[]		side[12, ]	dest[]	code: 

12	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: return switch-expression (param.substring(0,1)) [Return#String - Switch#String]


============================================================



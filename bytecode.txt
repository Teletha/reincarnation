java.lang.Error: 
============================================================
Javac compiles reincarnation.decompiler.flow.SwitchExpressionTest$9
============================================================
/reincarnation/decompiler/flow/SwitchExpressionTest.java:20: エラー: 文ではありません
                    value + 1;
                          ^
/reincarnation/decompiler/flow/SwitchExpressionTest.java:24: エラー: 文ではありません
                    value + 2;
                          ^

Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
NullPointerException: Cannot invoke "java.lang.Class.getDeclaredConstructors()" because "clazz" is null
    at reincarnation.CodeVerifier$JavaVerifier.<init>(CodeVerifier.java:379)
    at reincarnation.CodeVerifier.verify(CodeVerifier.java:182)
    at reincarnation.decompiler.flow.SwitchExpressionTest.blockInDefault(SwitchExpressionTest.java:156)

============================================================
Original Code
============================================================
void blockInDefault() {
        verify(new TestCode.IntParam() {

            @Override
            public int run(@Param(from = 0, to = 5) int param) {
                return switch (param) {
                case 0 -> {
                    int value = param;
                    yield value + 1;
                }
                case 1 -> {
                    int value = param;
                    yield value + 2;
                }
                default -> {
                    int value = param;
                    yield value + 3;
                }
                };
            }
        });
    }
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.IntParam;
05    import reincarnation.TestCode.Param;
06    import reincarnation.decompiler.flow.SwitchExpressionTest;
07    
08    class SwitchExpressionTest extends CodeVerifier {
09    
10        class SwitchExpressionTest$9 implements IntParam {
11    
12            SwitchExpressionTest$9(final SwitchExpressionTest this$0) {
13            }
14    
15            public int run(@Param(to = 5) int param) {
16                int value;
17                switch (param) {
18                    case 0:
19                        value = param;
20                        value + 1;
21                        // C -> E break(1 of 4) 
22                        break;
23                    case 1:
24                        value = param;
25                        value + 2;
26                        // D -> E break(2 of 4) 
27                        break;
28                    default :
29                        value = param;
30                        // B -> E break(3 of 4) 
31                        break;
32                }
33                return value + 3;
34            }
35        }
36    }
============================================================
Decompiling Log
============================================================
//-------------------------- SwitchExpressionTest#blockInDefault (SwitchExpressionTest.java:155) --------------------------//
Method blockInDefault() (SwitchExpressionTest.java:156)
0	in[]	out[]	dom[]	doms[]	side[ ,1]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]
1	in[]	out[]	dom[]	doms[]	side[0, ]	dest[]	code: 

Delete tail empty return (show full nodes)
0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall] return null [Return - null]

0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]


0	in[]	out[]	dom[]	doms[]	side[ , ]	dest[T]	code: java.lang.Object() [ConstructorCall]

//-------------------------- SwitchExpressionTest#blockInDefault (SwitchExpressionTest.java:159) --------------------------//
Method blockInDefault() (SwitchExpressionTest.java:160)
0	in[]		out[3,1,2]	dom[]	doms[]	side[ ,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[]	side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[5]		dom[1]	doms[]	side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[]	side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[5]		dom[2]	doms[]	side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[]	side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[5]		dom[3]	doms[]	side[3,5]	dest[5]	code: 
5	in[4,6,7]	out[]		dom[]	doms[]	side[7,8]	dest[T]	code: return value + 3 [Return#int - Binary#int]
8	in[]		out[]		dom[]	doms[]	side[5, ]	dest[]	code: 

Analyze variable declaration (show full nodes)
0	in[]		out[3,1,2]	dom[]	doms[]	side[ ,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[]	side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[5]		dom[1]	doms[]	side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[]	side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[5]		dom[2]	doms[]	side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[]	side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[5]		dom[3]	doms[]	side[3,5]	dest[5]	code: 
5	in[4,6,7]	out[]		dom[]	doms[]	side[7, ]	dest[T]	code: return value + 3 [Return#int - Binary#int]

A	in[]		out[0]		dom[]	doms[]	side[ ,0]	dest[0]	code: value [LocalVariable#int]
0	in[A]		out[3,1,2]	dom[A]	doms[]	side[A,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[]	side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[5]		dom[1]	doms[]	side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[]	side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[5]		dom[2]	doms[]	side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[]	side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[5]		dom[3]	doms[]	side[3,5]	dest[5]	code: 
5	in[4,6,7]	out[]		dom[]	doms[]	side[7, ]	dest[T]	code: return value + 3 [Return#int - Binary#int]


Analyze switch [Range A - 5] (show full nodes)
A	in[]		out[0]		dom[]	doms[0]			side[ ,0]	dest[0]	code: value [LocalVariable#int]
0	in[A]		out[3,1,2]	dom[A]	doms[1,2,3,5]	side[A,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[4]			side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[5]		dom[1]	doms[]			side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[6]			side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[5]		dom[2]	doms[]			side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[7]			side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[5]		dom[3]	doms[]			side[3,5]	dest[5]	code: 
5	in[4,6,7]	out[]		dom[]	doms[]			side[7, ]	dest[T]	code: return value + 3 [Return#int - Binary#int]

A	in[]		out[0]		dom[]	doms[0]			side[ ,0]	dest[0]	code: value [LocalVariable#int]
0	in[A]		out[3,1,2]	dom[A]	doms[1,2,3,5]	side[A,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[4]			side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[C]		dom[1]	doms[]			side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[6]			side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[D]		dom[2]	doms[]			side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[7]			side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[B]		dom[3]	doms[]			side[3,B]	dest[5]	code: 
B	in[7]		out[E]		dom[7]	doms[]			side[7,C]	dest[5]	code: 
C	in[4]		out[E]		dom[4]	doms[]			side[B,D]	dest[5]	code: 
D	in[6]		out[E]		dom[6]	doms[]			side[C,E]	dest[5]	code: 
E	in[B,C,D]	out[5]		dom[]	doms[]			side[D,5]	dest[5]	code: 
5	in[E]		out[]		dom[E]	doms[]			side[E, ]	dest[T]	code: return value + 3 [Return#int - Binary#int]


A	in[]		out[0]		dom[]	doms[0]			side[ ,0]	dest[0]	code: value [LocalVariable#int]
0	in[A]		out[3,1,2]	dom[A]	doms[1,2,3,5]	side[A,1]	dest[1]	code: switch (param) [Switch]
1	in[0]		out[4]		dom[0]	doms[4]			side[0,4]	dest[4]	code: value = param [Assign#int]
4	in[1]		out[C]		dom[1]	doms[]			side[1,2]	dest[5]	code: value + 1 [Binary#int]
2	in[0]		out[6]		dom[0]	doms[6]			side[4,6]	dest[6]	code: value = param [Assign#int]
6	in[2]		out[D]		dom[2]	doms[]			side[2,3]	dest[5]	code: value + 2 [Binary#int]
3	in[0]		out[7]		dom[0]	doms[7]			side[6,7]	dest[7]	code: value = param [Assign#int]
7	in[3]		out[B]		dom[3]	doms[]			side[3,B]	dest[5]	code: 
B	in[7]		out[E]		dom[7]	doms[]			side[7,C]	dest[5]	code: 
C	in[4]		out[E]		dom[4]	doms[]			side[B,D]	dest[5]	code: 
D	in[6]		out[E]		dom[6]	doms[]			side[C,E]	dest[5]	code: 
E	in[B,C,D]	out[5]		dom[]	doms[]			side[D,5]	dest[5]	code: 
5	in[E]		out[]		dom[E]	doms[]			side[E, ]	dest[T]	code: return value + 3 [Return#int - Binary#int]


============================================================
Bytecode Diff -  reincarnation.decompiler.flow.SwitchExpressionTest$9
============================================================
ECJ																		Javac
visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);						visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);
AnnotableParameterCount(1, true);										AnnotableParameterCount(1, true);
Label(L0);																Label(L0);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
~TableSwitchInsn~(0, 1~,~ ~L3~, new Label[] { L1, L2 });				+LookupSwitchInsn+(+L3, new int[] { +0, 1 +}+, new Label[] { L1, L2 });
Label(L1);																Label(L1);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
Label(L4);																Label(L4);
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
Insn(ICONST_1);															Insn(ICONST_1);
Insn(IADD);																Insn(IADD);
JumpInsn(GOTO, L5);														JumpInsn(GOTO, L5);
Label(L2);																Label(L2);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
Label(L6);																Label(L6);
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
Insn(ICONST_2);															Insn(ICONST_2);
Insn(IADD);																Insn(IADD);
JumpInsn(GOTO, L5);														JumpInsn(GOTO, L5);
Label(L3);																Label(L3);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
VarInsn(ISTORE, 2);														VarInsn(ISTORE, 2);
Label(L7);																Label(L7);
VarInsn(ILOAD, 2);														VarInsn(ILOAD, 2);
Insn(ICONST_3);															Insn(ICONST_3);
Insn(IADD);																Insn(IADD);
																		+JumpInsn(GOTO, L5);+
Label(L5);																Label(L5);
Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});						Frame(F_SAME1, 0, null, 1, new Object[] {INTEGER});
Insn(IRETURN);															Insn(IRETURN);
Label(L8);																Label(L8);
~LocalVariable("this", "LSwitchExpressionTest$9;", null, L0, L8, 0);~	
~LocalVariable("param", "I", null, L0, L8, 1);~							
LocalVariable("value", "I", null, L4, L2, 2);							LocalVariable("value", "I", null, L4, L2, 2);
LocalVariable("value", "I", null, L6, L3, 2);							LocalVariable("value", "I", null, L6, L3, 2);
LocalVariable("value", "I", null, L7, L5, 2);							LocalVariable("value", "I", null, L7, L5, 2);
																		+LocalVariable("this", "LSwitchExpressionTest$9;", null, L0, L8, 0);+
																		+LocalVariable("param", "I", null, L0, L8, 1);+
============================================================



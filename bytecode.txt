java.lang.Error: 
============================================================
Javac fails compiling reincarnation.decompiler.flow.TryFinallyTest$11
============================================================
null
============================================================
Original Code
============================================================
void returnInAfter() {
        verify(new TestCode.IntParam() {

            private int field = 1;

            @Override
            public int run(@Param(from = 0, to = 10) int param) {
                try {
                    field *= error(param);
                } catch (Error e) {
                    field -= 10;
                }
                return field;
            }

            private int error(int param) {
                try {
                    param = MaybeThrow.error(param);
                } finally {
                    param++;
                }
                return param;
            }
        });
    }
============================================================
Decompiled Code
============================================================
01    package reincarnation.decompiler.flow;
02    
03    import reincarnation.CodeVerifier;
04    import reincarnation.TestCode.IntParam;
05    import reincarnation.TestCode.Param;
06    import reincarnation.decompiler.flow.MaybeThrow;
07    import reincarnation.decompiler.flow.TryFinallyTest;
08    
09    class TryFinallyTest extends CodeVerifier {
10    
11        class TryFinallyTest$11 implements IntParam {
12            private int field;
13    
14            TryFinallyTest$11(final TryFinallyTest this$0) {
15                this.field = 1;
16            }
17    
18            public int run(@Param(to = 10) int param) {
19                try {
20                    this.field = this.field * this.error(param);
21                } catch(Error e) {
22                    this.field = (this.field - 10);
23                }
24                return this.field;
25            }
26    
27            private int error(int param) {
28                try {
29                    param = MaybeThrow.error(param);
30                    return param;
31                } finally {
32                    ++param;
33                }
34            }
35        }
36    }
============================================================
Decompiling Log
============================================================
//--------------------------------- TryFinallyTest#returnInAfter (TryFinallyTest.java:236) ---------------------------------//
Constructor() (TryFinallyTest.java:239)
0	in[]	out[1]	dom[]	doms[]	side[ ,1]	dest[1]	code: java.lang.Object() [ConstructorCall]
1	in[0]	out[]	dom[0]	doms[]	side[0,2]	dest[T]	code: this.field = 1 [Assign#int] return null [Return - null]
2	in[]	out[]	dom[]	doms[]	side[1, ]	dest[]	code: 

Delete tail empty return (show full nodes)
0	in[]	out[1]	dom[]	doms[1]	side[ ,1]	dest[1]	code: java.lang.Object() [ConstructorCall]
1	in[0]	out[]	dom[0]	doms[]	side[0, ]	dest[T]	code: this.field = 1 [Assign#int] return null [Return - null]

0	in[]	out[1]	dom[]	doms[1]	side[ ,1]	dest[1]	code: java.lang.Object() [ConstructorCall]
1	in[0]	out[]	dom[0]	doms[]	side[0, ]	dest[T]	code: this.field = 1 [Assign#int]


0	in[]	out[1]	dom[]	doms[1]	side[ ,1]	dest[1]	code: java.lang.Object() [ConstructorCall]
1	in[0]	out[]	dom[0]	doms[]	side[0, ]	dest[T]	code: this.field = 1 [Assign#int]

//--------------------------------- TryFinallyTest#returnInAfter (TryFinallyTest.java:243) ---------------------------------//
Method run(int arg0) (TryFinallyTest.java:248)
0	in[]	out[1]	dom[]	doms[]	side[ ,1]	dest[1]	try: s	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]	side[0,2]	dest[3]	try: e	code: 
2	in[]	out[4]	dom[]	doms[]	side[1,4]	dest[4]	try: c	code: 
4	in[2]	out[3]	dom[2]	doms[]	side[2,3]	dest[3]	try:   	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]	side[4,5]	dest[T]	try:   	code: return this.field [Return#int - FieldAccess#int]
5	in[]	out[]	dom[]	doms[]	side[3, ]	dest[]	try:   	code: 

Analyze try-catch-finally (show full nodes)
0	in[]	out[1]	dom[]	doms[1,2,3]	side[ ,1]	dest[1]	try: s	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]		side[0,2]	dest[3]	try: e	code: 
2	in[]	out[4]	dom[]	doms[4]		side[1,4]	dest[4]	try: c	code: 
4	in[2]	out[3]	dom[2]	doms[]		side[2,3]	dest[3]	try:   	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]		side[4, ]	dest[T]	try:   	code: return this.field [Return#int - FieldAccess#int]

0	in[]	out[1]	dom[]	doms[1,2,3]	side[ ,1]	dest[1]	try: s	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]		side[0,2]	dest[3]	try: e	code: 
2	in[]	out[4]	dom[]	doms[4]		side[1,4]	dest[4]	try: c	code: 
4	in[2]	out[3]	dom[2]	doms[]		side[2,3]	dest[3]	try:   	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]		side[4, ]	dest[T]	try: x	code: return this.field [Return#int - FieldAccess#int]


Analyze nodes (show full nodes)
0	in[]	out[1]	dom[]	doms[1,2,3]	side[ ,1]	dest[1]	try: s	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]		side[0,2]	dest[3]	try: e	code: 
2	in[]	out[4]	dom[]	doms[4]		side[1,4]	dest[4]	try: c	code: 
4	in[2]	out[3]	dom[2]	doms[]		side[2,3]	dest[3]	try:   	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]		side[4, ]	dest[T]	try: x	code: return this.field [Return#int - FieldAccess#int]

0	in[]	out[1]	dom[]	doms[1,2,3]	side[ ,1]	dest[1]	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]		side[0,2]	dest[3]	code: 
2	in[]	out[4]	dom[]	doms[4]		side[1,4]	dest[4]	code: 
4	in[2]	out[3]	dom[2]	doms[]		side[2,3]	dest[3]	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]		side[4, ]	dest[T]	code: return this.field [Return#int - FieldAccess#int]


0	in[]	out[1]	dom[]	doms[1,2,3]	side[ ,1]	dest[1]	code: this.field = this.field * this.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]		side[0,2]	dest[3]	code: 
2	in[]	out[4]	dom[]	doms[4]		side[1,4]	dest[4]	code: 
4	in[2]	out[3]	dom[2]	doms[]		side[2,3]	dest[3]	code: this.field = this.field - 10 [Assign#int]
3	in[1,4]	out[]	dom[]	doms[]		side[4, ]	dest[T]	code: return this.field [Return#int - FieldAccess#int]

//--------------------------------- TryFinallyTest#returnInAfter (TryFinallyTest.java:252) ---------------------------------//
Method error(int arg0) (TryFinallyTest.java:257)
0	in[]	out[1]	dom[]	doms[]	side[ ,1]	dest[1]	try: s	code: param = MaybeThrow.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]	side[0,3]	dest[3]	try: e	code: ++param [Unary#int]
3	in[1]	out[4]	dom[1]	doms[]	side[1,2]	dest[4]	try:   	code: 
2	in[]	out[5]	dom[]	doms[]	side[3,5]	dest[5]	try: c	code: ++param [Unary#int]
5	in[2]	out[]	dom[2]	doms[]	side[2,4]	dest[T]	try:   	code: throw local2 [Throw]
4	in[3]	out[]	dom[3]	doms[]	side[5,6]	dest[T]	try:   	code: return param [Return#int - LocalVariable#int]
6	in[]	out[]	dom[]	doms[]	side[4, ]	dest[]	try:   	code: 

Remove copied finally nodes [size: 1] from end's outgoings (show full nodes)
0	in[]	out[1]	dom[]	doms[]	side[ ,1]	dest[1]	try: s	code: param = MaybeThrow.error(param) [Assign#int]
1	in[0]	out[3]	dom[0]	doms[]	side[0,3]	dest[3]	try: e	code: ++param [Unary#int]
3	in[1]	out[4]	dom[1]	doms[]	side[1,2]	dest[4]	try:   	code: 
2	in[]	out[5]	dom[]	doms[]	side[3,5]	dest[5]	try: c	code: ++param [Unary#int]
5	in[2]	out[]	dom[2]	doms[]	side[2,4]	dest[T]	try:   	code: throw local2 [Throw]
4	in[3]	out[]	dom[3]	doms[]	side[5,6]	dest[T]	try:   	code: return param [Return#int - LocalVariable#int]
6	in[]	out[]	dom[]	doms[]	side[4, ]	dest[]	try:   	code: 

0	in[]	out[3]	dom[]	doms[]	side[ ,3]	dest[3]	try: s	code: param = MaybeThrow.error(param) [Assign#int]
3	in[0]	out[4]	dom[0]	doms[]	side[0,2]	dest[4]	try:   	code: 
2	in[]	out[5]	dom[]	doms[]	side[3,5]	dest[5]	try: c	code: ++param [Unary#int]
5	in[2]	out[]	dom[2]	doms[]	side[2,4]	dest[T]	try:   	code: throw local2 [Throw]
4	in[3]	out[]	dom[3]	doms[]	side[5,6]	dest[T]	try:   	code: return param [Return#int - LocalVariable#int]
6	in[]	out[]	dom[]	doms[]	side[4, ]	dest[]	try:   	code: 


Analyze nodes (show full nodes)
0	in[]	out[3]	dom[]	doms[3,2]	side[ ,3]	dest[3]	try: s	code: param = MaybeThrow.error(param) [Assign#int]
3	in[0]	out[4]	dom[0]	doms[4]		side[0,2]	dest[4]	try:   	code: 
2	in[]	out[]	dom[]	doms[]		side[3,4]	dest[4]	try: c	code: ++param [Unary#int]
4	in[3]	out[]	dom[3]	doms[]		side[2, ]	dest[T]	try:   	code: return param [Return#int - LocalVariable#int]

0	in[]	out[3]	dom[]	doms[3,2]	side[ ,3]	dest[3]	code: param = MaybeThrow.error(param) [Assign#int]
3	in[0]	out[4]	dom[0]	doms[4]		side[0,2]	dest[4]	code: 
2	in[]	out[]	dom[]	doms[]		side[3,4]	dest[4]	code: ++param [Unary#int]
4	in[3]	out[]	dom[3]	doms[]		side[2, ]	dest[T]	code: return param [Return#int - LocalVariable#int]


0	in[]	out[3]	dom[]	doms[3,2]	side[ ,3]	dest[3]	code: param = MaybeThrow.error(param) [Assign#int]
3	in[0]	out[4]	dom[0]	doms[4]		side[0,2]	dest[4]	code: 
2	in[]	out[]	dom[]	doms[]		side[3,4]	dest[4]	code: ++param [Unary#int]
4	in[3]	out[]	dom[3]	doms[]		side[2, ]	dest[T]	code: return param [Return#int - LocalVariable#int]


============================================================
Bytecode Diff -  reincarnation.decompiler.flow.TryFinallyTest$11
============================================================
ECJ																		Javac
visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);						visitMethod(ACC_PUBLIC, "run", "(I)I", null, null);
AnnotableParameterCount(1, true);										AnnotableParameterCount(1, true);
TryCatchBlock(L0, L1, L2, "j.l.Error");									TryCatchBlock(L0, L1, L2, "j.l.Error");
Label(L0);																Label(L0);
VarInsn(ALOAD, 0);														VarInsn(ALOAD, 0);
Insn(DUP);																Insn(DUP);
FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");					FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");
VarInsn(ALOAD, 0);														VarInsn(ALOAD, 0);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
MethodInsn(INVOKEVIRTUAL, "TryFinallyTest$11", "error", "(I)I", false);	MethodInsn(INVOKEVIRTUAL, "TryFinallyTest$11", "error", "(I)I", false);
Insn(IMUL);																Insn(IMUL);
FieldInsn(PUTFIELD, "TryFinallyTest$11", "field", "I");					FieldInsn(PUTFIELD, "TryFinallyTest$11", "field", "I");
Label(L1);																Label(L1);
JumpInsn(GOTO, L3);														JumpInsn(GOTO, L3);
Label(L2);																Label(L2);
Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});					Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Error"});
VarInsn(ASTORE, 2);														VarInsn(ASTORE, 2);
Label(L4);																Label(L4);
VarInsn(ALOAD, 0);														VarInsn(ALOAD, 0);
Insn(DUP);																Insn(DUP);
FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");					FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");
IntInsn(BIPUSH, 10);													IntInsn(BIPUSH, 10);
Insn(ISUB);																Insn(ISUB);
FieldInsn(PUTFIELD, "TryFinallyTest$11", "field", "I");					FieldInsn(PUTFIELD, "TryFinallyTest$11", "field", "I");
Label(L3);																Label(L3);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
VarInsn(ALOAD, 0);														VarInsn(ALOAD, 0);
FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");					FieldInsn(GETFIELD, "TryFinallyTest$11", "field", "I");
Insn(IRETURN);															Insn(IRETURN);
Label(L5);																Label(L5);
																		+LocalVariable("e", "Lj.l.Error;", null, L4, L3, 2);+
LocalVariable("this", "LTryFinallyTest$11;", null, L0, L5, 0);			LocalVariable("this", "LTryFinallyTest$11;", null, L0, L5, 0);
LocalVariable("param", "I", null, L0, L5, 1);							LocalVariable("param", "I", null, L0, L5, 1);
~LocalVariable("e", "Lj.l.Error;", null, L4, L3, 2);~					
																		
visitMethod(ACC_PRIVATE, "error", "(I)I", null, null);					visitMethod(ACC_PRIVATE, "error", "(I)I", null, null);
TryCatchBlock(L0, L1, ~L1~, null);										TryCatchBlock(L0, L1, +L2+, null);
Label(L0);																Label(L0);
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);			MethodInsn(INVOKESTATIC, "MaybeThrow", "error", "(I)I", false);
VarInsn(ISTORE, 1);														VarInsn(ISTORE, 1);
~Label(L2);~															
~JumpInsn(GOTO, L3);~													
Label(L1);																Label(L1);
																		+IincInsn(1, 1);+
																		+Label(L3);+
																		+JumpInsn(GOTO, L4);+
																		+Label(L2);+
Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Throwable"});				Frame(F_SAME1, 0, null, 1, new Object[] {"j.l.Throwable"});
VarInsn(ASTORE, 2);														VarInsn(ASTORE, 2);
~Label(L4);~															
IincInsn(1, 1);															IincInsn(1, 1);
Label(L5);																Label(L5);
VarInsn(ALOAD, 2);														VarInsn(ALOAD, 2);
Insn(ATHROW);															Insn(ATHROW);
Label(~L3~);															Label(+L4+);
Frame(F_SAME, 0, null, 0, null);										Frame(F_SAME, 0, null, 0, null);
~IincInsn(1, 1);~														
~Label(L6);~															
VarInsn(ILOAD, 1);														VarInsn(ILOAD, 1);
Insn(IRETURN);															Insn(IRETURN);
Label(~L7~);															Label(+L6+);
LocalVariable("this", "LTryFinallyTest$11;", null, L0, ~L7~, 0);		LocalVariable("this", "LTryFinallyTest$11;", null, L0, +L6+, 0);
LocalVariable("param", "I", null, L0, ~L7~, 1);							LocalVariable("param", "I", null, L0, +L6+, 1);
============================================================


